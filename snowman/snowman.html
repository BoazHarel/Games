<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Christmas Snowman Builder</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden; /* Prevent scrolling */
            background: linear-gradient(to bottom, #0f2027, #203a43, #2c5364);
            touch-action: none; /* Disable default touch actions */
            font-family: 'Arial', sans-serif;
        }

        #gameCanvas {
            display: block;
            touch-action: none;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100px;
            background: rgba(255, 255, 255, 0.2);
            display: flex;
            justify-content: space-around;
            align-items: center;
            border-bottom: 2px solid rgba(255,255,255,0.3);
            pointer-events: none; /* Let clicks pass through to canvas, logic handled in JS */
            z-index: 10;
        }

        .instruction {
            position: absolute;
            bottom: 20px;
            width: 100%;
            text-align: center;
            color: white;
            font-size: 1.2rem;
            text-shadow: 0px 2px 4px rgba(0,0,0,0.5);
            pointer-events: none;
            opacity: 0.8;
            animation: fadeOut 8s forwards;
            user-select: none;
        }

        #mute-btn {
            position: absolute;
            bottom: 10px;
            right: 10px;
            font-size: 24px;
            background: none;
            border: none;
            color: white;
            opacity: 0.5;
            cursor: pointer;
            z-index: 20;
        }

        @keyframes fadeOut {
            0% { opacity: 1; }
            80% { opacity: 1; }
            100% { opacity: 0; }
        }
    </style>
</head>
<body>

<div id="ui-layer">
    <!-- Visual cues for the toolbar -->
</div>

<div class="instruction">Stack 3 snowballs to make them come alive! üéÅ Try the Gift Box!</div>
<button id="mute-btn">üîä</button>
<canvas id="gameCanvas"></canvas>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    // --- Audio Engine (Synthesized) ---
    const AudioEngine = {
        ctx: null,
        enabled: true,
        init: function() {
            window.AudioContext = window.AudioContext || window.webkitAudioContext;
            this.ctx = new AudioContext();
        },
        playTone: function(freq, type, duration, vol = 0.1) {
            if (!this.enabled || !this.ctx) return;
            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();
            osc.type = type;
            osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
            gain.gain.setValueAtTime(vol, this.ctx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
            osc.connect(gain);
            gain.connect(this.ctx.destination);
            osc.start();
            osc.stop(this.ctx.currentTime + duration);
        },
        playPop: function() { this.playTone(600, 'sine', 0.1); },
        playThud: function() { this.playTone(100, 'triangle', 0.1, 0.2); },
        playSplash: function() {
            // Simple noise burst approximation
            if (!this.enabled || !this.ctx) return;
            const bufferSize = this.ctx.sampleRate * 0.5;
            const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
            const noise = this.ctx.createBufferSource();
            noise.buffer = buffer;
            const gain = this.ctx.createGain();
            gain.gain.setValueAtTime(0.1, this.ctx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.5);
            noise.connect(gain);
            gain.connect(this.ctx.destination);
            noise.start();
        },
        playSuccess: function() {
            if (!this.enabled || !this.ctx) return;
            const now = this.ctx.currentTime;
            [523.25, 659.25, 783.99, 1046.50].forEach((freq, i) => {
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = 'sine';
                osc.frequency.setValueAtTime(freq, now + i * 0.1);
                gain.gain.setValueAtTime(0.1, now + i * 0.1);
                gain.gain.exponentialRampToValueAtTime(0.01, now + i * 0.1 + 0.5);
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.start(now + i * 0.1);
                osc.stop(now + i * 0.1 + 0.5);
            });
        }
    };

    document.getElementById('mute-btn').addEventListener('click', () => {
        if (!AudioEngine.ctx) AudioEngine.init(); // Init on first user interaction
        AudioEngine.enabled = !AudioEngine.enabled;
        document.getElementById('mute-btn').textContent = AudioEngine.enabled ? 'üîä' : 'üîá';
    });

    // Init audio on first touch anywhere if not ready
    document.addEventListener('touchstart', () => { if(!AudioEngine.ctx) AudioEngine.init(); }, {once:true});
    document.addEventListener('mousedown', () => { if(!AudioEngine.ctx) AudioEngine.init(); }, {once:true});


    // Game State
    let width, height;
    let snowflakes = [];
    let gameObjects = [];
    let confetti = [];
    let draggingItem = null;
    let dragOffsetX = 0;
    let dragOffsetY = 0;

    // Rolling State
    let isRolling = false;
    let rollingBall = null;
    let lastRollPos = {x:0, y:0};

    // Global Animation Time
    let time = 0;
    let windSpeed = 0;

    // Configuration
    const GROUND_HEIGHT_RATIO = 0.25;
    const MAX_SNOWFLAKES = 100;
    const TOOLBAR_HEIGHT = 100;
    const GRAVITY = 0.8;
    const BOUNCE = 0.2;
    const FRICTION = 0.9;

    // Lake Config
    let LAKE_RADIUS = 200;

    // Palette
    const COLORS = {
        skyTop: '#1a2a6c',
        skyBottom: '#b21f1f',
        skyBottom2: '#fdbb2d',
        ground: '#F0F8FF',
        snow: '#FFFFFF'
    };

    // Tools available in the toolbar
    const TOOLS = [
        { type: 'hat', icon: 'üé©', x: 0, y: 50, size: 50 },
        { type: 'carrot', icon: 'ü•ï', x: 0, y: 50, size: 40 },
        { type: 'eye', icon: '‚ö´', x: 0, y: 50, size: 20 },
        { type: 'stick', icon: 'STICK_DRAW', x: 0, y: 50, size: 45 },
        { type: 'scarf', icon: 'üß£', x: 0, y: 50, size: 50 },
        { type: 'arms', icon: 'ARMS_DRAW', x: 0, y: 50, size: 40 },
        { type: 'gift', icon: 'üéÅ', x: 0, y: 50, size: 45 } // NEW
    ];

    // Initialization
    function resize() {
        width = window.innerWidth;
        height = window.innerHeight;
        canvas.width = width;
        canvas.height = height;

        LAKE_RADIUS = Math.min(width, height) * 0.35;
        if (LAKE_RADIUS < 150) LAKE_RADIUS = 150;

        const spacing = width / TOOLS.length;
        TOOLS.forEach((tool, index) => {
            tool.x = (spacing * index) + (spacing / 2);
        });
    }

    window.addEventListener('resize', resize);
    resize();

    // --- Classes ---

    class Confetti {
        constructor(x, y) {
            this.x = x;
            this.y = y;
            this.vx = (Math.random() - 0.5) * 10;
            this.vy = (Math.random() - 0.5) * 10 - 5;
            this.size = Math.random() * 5 + 5;
            this.color = `hsl(${Math.random() * 360}, 100%, 50%)`;
            this.life = 100;
        }
        update() {
            this.x += this.vx;
            this.y += this.vy;
            this.vy += 0.2; // Gravity
            this.vx *= 0.95;
            this.life -= 1;
        }
        draw() {
            ctx.fillStyle = this.color;
            ctx.fillRect(this.x, this.y, this.size, this.size);
        }
    }

    class Snowflake {
        constructor() {
            this.reset();
        }

        reset() {
            this.x = Math.random() * width;
            this.y = Math.random() * -height;
            this.size = Math.random() * 3 + 2;
            this.speed = Math.random() * 1 + 0.5;
            this.wobble = Math.random() * Math.PI * 2;
        }

        update() {
            this.y += this.speed;
            this.x += Math.sin(this.wobble) * 0.5 + windSpeed * 2; // Add wind
            this.wobble += 0.05;

            if (this.y > height - (height * GROUND_HEIGHT_RATIO) + 20) {
                this.reset();
            }
        }

        draw() {
            ctx.fillStyle = "rgba(255, 255, 255, 0.8)";
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
            ctx.fill();
        }
    }

    class GameObject {
        constructor(type, x, y, size, icon = null) {
            this.type = type; // 'snowball', 'decoration', 'gift'
            this.x = x;
            this.y = y;
            this.size = size;
            this.icon = icon;
            this.isDragging = false;
            this.isDead = false;

            // Physics properties
            this.vx = 0;
            this.vy = 0;
            this.mass = type === 'snowball' ? size : size * 0.5;

            // Attachment properties
            this.parent = null;
            this.children = [];
            this.offsetX = 0;
            this.offsetY = 0;

            // Animation
            this.rotation = 0;
            this.danceOffset = 0;
            this.isAlive = false; // For snowman stack
        }

        updatePhysics(groundLevel, allObjects) {
            // "Living" Animation state (if part of a complete snowman)
            if (this.parent && this.parent.isAlive) {
                this.isAlive = true;
            }
            if (this.isAlive && !this.isDragging) {
                // Gentle sway
                this.danceOffset = Math.sin(time * 0.05 + (this.y * 0.01)) * 3;
            } else {
                this.danceOffset = 0;
            }

            // If attached to a parent, just follow it.
            if (this.parent) {
                this.x = this.parent.x + this.offsetX + this.danceOffset;
                this.y = this.parent.y + this.offsetY;
                // Add sway to rotation for arms/scarf
                if (this.type === 'decoration') {
                    this.rotation = Math.sin(time * 0.1) * 0.1;
                }
                this.vx = 0;
                this.vy = 0;
                return;
            }

            // Check Lake Collision
            const distToLake = Math.sqrt((this.x - width)**2 + (this.y - height)**2);
            if (distToLake < LAKE_RADIUS) {
                if (!this.sinking) AudioEngine.playSplash();
                this.sinking = true;

                this.x += (width - this.x) * 0.05;
                this.y += 2;
                this.size *= 0.95;

                if (this.size < 5) {
                    this.isDead = true;
                    if (this.children.length > 0) {
                        this.children.forEach(child => child.isDead = true);
                    }
                }
                return;
            }

            if (this.isDragging) {
                this.vx = 0;
                this.vy = 0;
                return;
            }

            // LOCK PHYSICS for Living Snowmen so they don't fall off while dancing
            if (this.isAlive) {
                this.vx = 0;
                this.vy = 0;
                return;
            }

            // Apply Gravity
            this.vy += GRAVITY;
            this.y += this.vy;
            this.x += this.vx;

            // Air Friction
            this.vx *= FRICTION;

            // 1. Ground Collision
            let bottomY = this.y + (this.type === 'snowball' ? this.size : this.size/2);

            if (bottomY > groundLevel) {
                this.y = groundLevel - (this.type === 'snowball' ? this.size : this.size/2);

                // Play thud sound on impact if speed was high
                if (Math.abs(this.vy) > 2) AudioEngine.playThud();

                this.vy *= -BOUNCE;
                if (Math.abs(this.vy) < 1) this.vy = 0;
                this.vx *= 0.8;
            }

            // 2. Object Collision
            for (let other of allObjects) {
                if (other === this) continue;
                if (other.isDragging) continue;
                if (other.parent) continue;
                if (other.isDead) continue;

                let dist = Math.sqrt((this.x - other.x)**2 + (this.y - other.y)**2);
                let minDist = (this.type === 'snowball' ? this.size : 15) +
                              (other.type === 'snowball' ? other.size : 15);

                if (dist < minDist && this.y < other.y) {
                    let angle = Math.atan2(this.y - other.y, this.x - other.x);
                    let overlap = minDist - dist;
                    this.y += Math.sin(angle) * overlap;
                    this.vx += Math.cos(angle) * 0.1;
                    this.vy *= -0.1;
                    this.vx *= 0.6;

                    // Trigger sound on collision occasionally
                    if (Math.abs(this.vy) > 1) AudioEngine.playThud();
                }
            }

            // Screen Boundaries
            if (this.x < 0) { this.x = 0; this.vx *= -1; }
            if (this.x > width) { this.x = width; this.vx *= -1; }
        }

        draw() {
            const drawX = this.x + this.danceOffset;

            if (this.type === 'snowball') {
                ctx.fillStyle = "rgba(0,0,0,0.1)";
                ctx.beginPath();
                ctx.arc(drawX + 5, this.y + 5, this.size, 0, Math.PI * 2);
                ctx.fill();

                const grad = ctx.createRadialGradient(drawX - this.size/3, this.y - this.size/3, this.size/4, drawX, this.y, this.size);
                grad.addColorStop(0, "#ffffff");
                grad.addColorStop(1, "#e6f0fa");

                ctx.fillStyle = grad;
                ctx.beginPath();
                ctx.arc(drawX, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();

                ctx.strokeStyle = "#dcecf9";
                ctx.lineWidth = 2;
                ctx.stroke();

            } else if (this.icon === 'STICK_DRAW') {
                ctx.save();
                ctx.translate(drawX, this.y);
                ctx.rotate(this.rotation);
                ctx.strokeStyle = '#5D4037';
                ctx.lineWidth = this.size / 6;
                ctx.lineCap = 'round';
                ctx.beginPath();
                ctx.moveTo(-this.size/3, +this.size/2);
                ctx.lineTo(+this.size/3, -this.size/2);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(+this.size/4, -this.size/6);
                ctx.stroke();
                ctx.restore();

            } else if (this.icon === 'ARMS_DRAW') {
                ctx.save();
                ctx.translate(drawX, this.y);
                ctx.rotate(this.rotation + Math.sin(time * 0.1)*0.2); // Extra wave for arms
                ctx.strokeStyle = '#5D4037';
                ctx.lineWidth = this.size / 8;
                ctx.lineCap = 'round';

                ctx.beginPath();
                ctx.moveTo(-this.size/2, -this.size/4);
                ctx.lineTo(0, +this.size/4);
                ctx.moveTo(-this.size/4, 0);
                ctx.lineTo(-this.size/2, +this.size/8);
                ctx.stroke();

                ctx.beginPath();
                ctx.moveTo(+this.size/2, -this.size/4);
                ctx.lineTo(0, +this.size/4);
                ctx.moveTo(+this.size/4, 0);
                ctx.lineTo(+this.size/2, +this.size/8);
                ctx.stroke();
                ctx.restore();

            } else if (this.type === 'gift') {
                 ctx.save();
                 ctx.translate(drawX, this.y);
                 // Box
                 ctx.fillStyle = '#D32F2F'; // Red box
                 ctx.fillRect(-20, -20, 40, 40);
                 // Ribbon
                 ctx.fillStyle = '#FFD700'; // Gold ribbon
                 ctx.fillRect(-5, -20, 10, 40);
                 ctx.fillRect(-20, -5, 40, 10);
                 ctx.restore();

            } else {
                ctx.save();
                ctx.translate(drawX, this.y);

                // Wind effect on scarf
                if (this.icon === 'üß£') {
                     ctx.rotate(Math.sin(time * 0.15 + windSpeed * 5) * 0.3);
                } else {
                     ctx.rotate(this.rotation);
                }

                ctx.font = `${this.size}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';

                ctx.fillStyle = "rgba(0,0,0,0.2)";
                ctx.fillText(this.icon, 2, 2);

                ctx.fillStyle = "#000";
                ctx.fillText(this.icon, 0, 0);
                ctx.restore();
            }
        }

        isHit(tx, ty) {
            const hitSize = this.type === 'snowball' ? this.size : this.size;
            const dist = Math.sqrt((tx - this.x) ** 2 + (ty - this.y) ** 2);
            return dist < hitSize + 15;
        }
    }

    // Populate Snowflakes
    for (let i = 0; i < MAX_SNOWFLAKES; i++) {
        snowflakes.push(new Snowflake());
    }

    // --- Logic: Detect Snowmen ---
    function checkSnowmanAlive() {
        // Reset alive state
        gameObjects.forEach(o => o.isAlive = false);

        // Find stacks of 3 snowballs
        const balls = gameObjects.filter(o => o.type === 'snowball' && !o.isDragging && !o.isDead);

        // Simple heuristic: A ball is "on" another if distance is close and Y is higher (smaller value)
        // We look for Bottom -> Middle -> Top

        balls.forEach(bottom => {
            if (bottom.size < 40) return; // Must be decent base

            // Find middle
            const middle = balls.find(m =>
                m !== bottom &&
                Math.abs(m.x - bottom.x) < bottom.size &&
                m.y < bottom.y &&
                m.y > bottom.y - bottom.size * 2.5
            );

            if (middle) {
                // Find top
                const top = balls.find(t =>
                    t !== bottom && t !== middle &&
                    Math.abs(t.x - middle.x) < middle.size &&
                    t.y < middle.y &&
                    t.y > middle.y - middle.size * 2.5
                );

                if (top) {
                    // We have a stack of 3!
                    if (!bottom.wasAlive) {
                        // Just became alive!
                        AudioEngine.playSuccess();
                        createConfetti(top.x, top.y);
                        bottom.wasAlive = true;
                    }
                    bottom.isAlive = true;
                    middle.isAlive = true;
                    top.isAlive = true;
                } else {
                    bottom.wasAlive = false;
                }
            } else {
                bottom.wasAlive = false;
            }
        });
    }

    function createConfetti(x, y) {
        for(let i=0; i<30; i++) {
            confetti.push(new Confetti(x, y));
        }
    }

    // --- Input Handling ---

    function getTouchPos(e) {
        const rect = canvas.getBoundingClientRect();
        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        const clientY = e.touches ? e.touches[0].clientY : e.clientY;
        return {
            x: clientX - rect.left,
            y: clientY - rect.top
        };
    }

    function handleStart(e) {
        if (e.cancelable) e.preventDefault();
        const pos = getTouchPos(e);
        AudioEngine.playPop();

        // 1. Check Toolbar
        if (pos.y < TOOLBAR_HEIGHT) {
            TOOLS.forEach(tool => {
                const dist = Math.sqrt((pos.x - tool.x) ** 2 + (pos.y - tool.y) ** 2);
                if (dist < 40) {
                    const newType = tool.type === 'gift' ? 'gift' : 'decoration';
                    const newDeco = new GameObject(newType, pos.x, pos.y, tool.size, tool.icon);
                    gameObjects.push(newDeco);
                    draggingItem = newDeco;
                    draggingItem.isDragging = true;
                    dragOffsetX = 0;
                    dragOffsetY = 0;
                }
            });
            return;
        }

        // 2. Check Existing Objects
        for (let i = gameObjects.length - 1; i >= 0; i--) {
            if (gameObjects[i].isHit(pos.x, pos.y)) {

                // Special: Click Gift to open
                if (gameObjects[i].type === 'gift' && !gameObjects[i].isDragging) {
                    openGift(gameObjects[i]);
                    return;
                }

                draggingItem = gameObjects[i];

                // DETACH if attached
                if (draggingItem.parent) {
                    const parent = draggingItem.parent;
                    const childIndex = parent.children.indexOf(draggingItem);
                    if (childIndex > -1) {
                        parent.children.splice(childIndex, 1);
                    }
                    draggingItem.parent = null;
                }

                draggingItem.isDragging = true;
                draggingItem.vx = 0;
                draggingItem.vy = 0;
                dragOffsetX = draggingItem.x - pos.x;
                dragOffsetY = draggingItem.y - pos.y;

                gameObjects.splice(i, 1);
                gameObjects.push(draggingItem);

                // If parent moved, bring children
                if (draggingItem.children && draggingItem.children.length > 0) {
                    draggingItem.children.forEach(child => {
                        const cIndex = gameObjects.indexOf(child);
                        if (cIndex > -1) {
                            gameObjects.splice(cIndex, 1);
                            gameObjects.push(child);
                        }
                    });
                }

                return;
            }
        }

        // 3. Ground Interaction -> Start Rolling
        const groundLevel = height - (height * GROUND_HEIGHT_RATIO);
        if (pos.y > groundLevel - 50) {
            isRolling = true;
            lastRollPos = pos;

            // Start a tiny snowball
            rollingBall = new GameObject('snowball', pos.x, pos.y, 10);
            rollingBall.isDragging = true;
            gameObjects.push(rollingBall);
        }
    }

    function openGift(gift) {
        // Remove gift box
        gift.isDead = true;
        AudioEngine.playSuccess();
        createConfetti(gift.x, gift.y);

        // Spawn random special item
        const specialItems = [
            {icon: 'üëë', size: 50}, // Crown
            {icon: 'üëì', size: 40}, // Glasses
            {icon: 'üéÄ', size: 40}, // Bow
            {icon: 'üç≠', size: 45}, // Lollipop
            {icon: 'üß¢', size: 50}  // Blue Cap
        ];
        const randomItem = specialItems[Math.floor(Math.random() * specialItems.length)];
        const newItem = new GameObject('decoration', gift.x, gift.y - 20, randomItem.size, randomItem.icon);
        newItem.vy = -5; // Pop up
        gameObjects.push(newItem);
    }

    function handleMove(e) {
        if (e.cancelable) e.preventDefault();
        const pos = getTouchPos(e);

        if (draggingItem) {
            draggingItem.x = pos.x + dragOffsetX;
            draggingItem.y = pos.y + dragOffsetY;
            draggingItem.vx = 0;
            draggingItem.vy = 0;

        } else if (isRolling && rollingBall) {
            const dx = pos.x - lastRollPos.x;
            const dy = pos.y - lastRollPos.y;
            const dist = Math.sqrt(dx*dx + dy*dy);

            rollingBall.x = pos.x;
            const groundY = height - (height * GROUND_HEIGHT_RATIO);
            rollingBall.y = Math.max(pos.y, groundY);

            if (rollingBall.size < 80) {
                rollingBall.size += dist * 0.05;
                if(dist > 5 && Math.random() > 0.8) AudioEngine.playPop(); // Crunch sound
            }

            lastRollPos = pos;
        }
    }

    function handleEnd(e) {
        if (draggingItem) {
            draggingItem.isDragging = false;

            // ATTACH logic
            if (draggingItem.type === 'decoration') {
                for (const other of gameObjects) {
                    if (other.type === 'snowball' && other !== draggingItem) {
                        const dist = Math.sqrt((draggingItem.x - other.x)**2 + (draggingItem.y - other.y)**2);
                        if (dist < other.size) {
                            draggingItem.parent = other;
                            other.children.push(draggingItem);
                            draggingItem.offsetX = draggingItem.x - other.x;
                            draggingItem.offsetY = draggingItem.y - other.y;
                            draggingItem.vx = 0;
                            draggingItem.vy = 0;
                            AudioEngine.playPop();
                            break;
                        }
                    }
                }
            }

            // Delete if in toolbar
            if (!draggingItem.parent && draggingItem.y < TOOLBAR_HEIGHT) {
                const index = gameObjects.indexOf(draggingItem);
                if (index > -1) gameObjects.splice(index, 1);
            }
            draggingItem = null;
        }

        if (isRolling) {
            isRolling = false;
            if (rollingBall) {
                rollingBall.isDragging = false;
                if (rollingBall.size < 15) {
                    const index = gameObjects.indexOf(rollingBall);
                    if (index > -1) gameObjects.splice(index, 1);
                }
                rollingBall = null;
            }
        }
    }

    canvas.addEventListener('mousedown', handleStart);
    canvas.addEventListener('mousemove', handleMove);
    canvas.addEventListener('mouseup', handleEnd);
    canvas.addEventListener('touchstart', handleStart, {passive: false});
    canvas.addEventListener('touchmove', handleMove, {passive: false});
    canvas.addEventListener('touchend', handleEnd);

    // --- Game Loop ---

    function drawToolbar() {
        ctx.fillStyle = "rgba(255,255,255,0.1)";
        ctx.fillRect(0, 0, width, TOOLBAR_HEIGHT);

        TOOLS.forEach(tool => {
            ctx.fillStyle = "rgba(255,255,255,0.3)";
            ctx.beginPath();
            ctx.arc(tool.x, tool.y, 35, 0, Math.PI*2);
            ctx.fill();

            if (tool.icon === 'STICK_DRAW') {
                ctx.save();
                ctx.translate(tool.x, tool.y);
                ctx.strokeStyle = '#5D4037';
                ctx.lineWidth = 4;
                ctx.lineCap = 'round';
                ctx.beginPath();
                ctx.moveTo(-10, 15);
                ctx.lineTo(10, -15);
                ctx.stroke();
                ctx.restore();
            } else if (tool.icon === 'ARMS_DRAW') {
                ctx.save();
                ctx.translate(tool.x, tool.y);
                ctx.strokeStyle = '#5D4037';
                ctx.lineWidth = 3;
                ctx.lineCap = 'round';
                ctx.beginPath();
                ctx.moveTo(-10, -5);
                ctx.lineTo(0, 10);
                ctx.lineTo(10, -5);
                ctx.stroke();
                ctx.restore();
            } else {
                ctx.font = "40px Arial";
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.fillStyle = "#FFF";
                ctx.fillText(tool.icon, tool.x, tool.y);
            }
        });
    }

    function drawBackground() {
        const grad = ctx.createLinearGradient(0, 0, 0, height);
        grad.addColorStop(0, COLORS.skyTop);
        grad.addColorStop(0.5, "#3a6073");
        grad.addColorStop(1, "#3a6073");
        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, width, height);

        /* Moon removed
        ctx.fillStyle = "#fffc";
        ctx.shadowBlur = 20;
        ctx.shadowColor = "white";
        ctx.beginPath();
        ctx.arc(width - 80, 80, 40, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;
        */

        const groundH = height * GROUND_HEIGHT_RATIO;
        ctx.fillStyle = COLORS.ground;

        ctx.beginPath();
        ctx.moveTo(0, height - groundH);
        ctx.bezierCurveTo(width / 2, height - groundH - 50, width / 2, height - groundH + 50, width, height - groundH);
        ctx.lineTo(width, height);
        ctx.lineTo(0, height);
        ctx.fill();

        // Draw Lake
        ctx.fillStyle = "#4a90e2";
        ctx.beginPath();
        ctx.arc(width, height, LAKE_RADIUS, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = "#a4d4ff";
        ctx.lineWidth = 5;
        ctx.stroke();
    }

    function animate() {
        time++;
        // Wind oscilates
        windSpeed = Math.sin(time * 0.01) * 0.5;

        ctx.clearRect(0, 0, width, height);
        drawBackground();

        snowflakes.forEach(flake => {
            flake.update();
            flake.draw();
        });

        const groundLevel = height - (height * GROUND_HEIGHT_RATIO) + 20;

        checkSnowmanAlive();

        gameObjects.forEach(obj => {
            obj.updatePhysics(groundLevel, gameObjects);
        });

        // Update Confetti
        confetti = confetti.filter(c => c.life > 0);
        confetti.forEach(c => {
            c.update();
            c.draw();
        });

        gameObjects = gameObjects.filter(obj => !obj.isDead);
        gameObjects.forEach(obj => obj.draw());

        drawToolbar();

        requestAnimationFrame(animate);
    }

    animate();

</script>
</body>
</html>